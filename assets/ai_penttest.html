<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>Security Workflow Demo - Mobile</title>
  <style>
    :root{
      --bg:#0b1020; --text:#eaf2ff; --muted:#9fb3d6;
      --line:rgba(140,170,255,.35); --accent:#7dd3fc;
      --pink:#f472b6; --blue:#60a5fa; --green:#34d399; --yellow:#facc15; --orange:#fb923c; --purple:#a78bfa;
      --red:#ff5c5c; --blue-ok:#5bbcff;
    }
    html,body{margin:0;padding:0;height:100vh;background:#111;overflow:hidden;font-size:14px}
    
    /* Desktop styles (unchanged) */
    @media (min-width: 768px) {
      #container{
        display:flex;height:100vh;width:100vw;
      }
      #wf{
        flex:1;background:var(--bg);position:relative;
        font:500 14px/1 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; color:var(--text);
      }
      #sidebar{
        width:320px;background:#0a0f1f;border-left:1px solid rgba(255,255,255,.08);
        display:flex;flex-direction:column;padding:12px;
      }
      .hdr{
        position:absolute;top:0;left:0;right:0;height:50px;display:flex;align-items:center;gap:10px;padding:0 16px;
        background:linear-gradient(90deg,#0f1734,#0b1330);font-weight:400;z-index:100;font-size:20px;opacity:1;
        font-family:ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
      }
      .stage{position:absolute;bottom:15px;left:20px;color:var(--text);font-weight:700;font-size:23px;z-index:100;opacity:1}
      .log h4{margin:0 0 12px 0;font-size:22px;color:#ffffff;opacity:.9;font-weight:600}
      .stats h4{margin:0 0 8px 0;font-size:18px;color:#ffffff;font-weight:600}
      .stat-row{display:flex;justify-content:space-between;margin-bottom:8px;font-size:16px;color:#ffffff}
    }
    
    /* Mobile styles - OPTIMIZED */
    @media (max-width: 767px) {
      #container{
        display:flex;height:100vh;width:100vw;
      }
      #wf{
        flex:1;background:var(--bg);position:relative;
        font:500 12px/1 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; color:var(--text);
      }
      #sidebar{
        width:110px;background:#0a0f1f;border-left:1px solid rgba(255,255,255,.08);
        display:flex;flex-direction:column;padding:4px;gap:4px;
      }
      .hdr{
        position:absolute;top:0;left:0;right:0;height:35px;display:flex;align-items:center;gap:4px;padding:0 8px;
        background:linear-gradient(90deg,#0f1734,#0b1330);font-weight:400;z-index:100;font-size:11px;opacity:1;
        flex-wrap:wrap;font-family:ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
      }
      .stage{
        position:absolute;bottom:6px;left:8px;right:11px;color:var(--text);font-weight:600;font-size:10px;z-index:100;opacity:1;
        text-align:center;background:rgba(11,16,32,0.9);padding:4px 6px;border-radius:6px;
        backdrop-filter:blur(4px);border:1px solid rgba(255,255,255,.1);
      }
      .log{
        flex:1;background:#0b152c;border:1px solid rgba(255,255,255,.08);border-radius:4px;padding:2px;
        overflow:auto;margin-bottom:4px;
      }
      .log h4{margin:0 0 2px 0;font-size:8px;color:#ffffff;opacity:.9;font-weight:600}
      .stats{
        background:#0b152c;border:1px solid rgba(255,255,255,.08);border-radius:4px;padding:2px;
      }
      .stats h4{margin:0 0 2px 0;font-size:7px;color:#ffffff;font-weight:600}
      .stat-row{display:flex;justify-content:space-between;margin-bottom:1px;font-size:6px;color:#ffffff}
      .log .item{
        padding:2px 3px;margin-bottom:2px;font-size:6px;
      }
      .sev{font-size:5px;padding:1px 2px;}
    }

    .tag{font:600 11px/1 ui-sans-serif;border:1px solid rgba(255,255,255,.12);padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.06)}
    .controls{
      display: none;
    }
    .log{
      background:#0b152c;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:12px;
      overflow:auto;margin-bottom:12px;
    }
    .log .item{display:flex;justify-content:space-between;align-items:center;gap:8px;
               padding:10px 12px;border-radius:10px;margin-bottom:10px;background:linear-gradient(135deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
               border:1px solid rgba(255,255,255,.18);font-size:14px;color:#ffffff;
               box-shadow:0 4px 12px rgba(0,0,0,.2);transition:all 0.3s ease;
               backdrop-filter:blur(8px);position:relative;overflow:hidden}
    .log .item:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(0,0,0,.3);border-color:rgba(255,255,255,.25)}
    .log .item::before{content:'';position:absolute;top:0;left:0;right:0;height:2px;
                       background:linear-gradient(90deg, var(--red), var(--orange), var(--yellow));opacity:.7}
    .sev{font-size:12px;padding:5px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.2);white-space:nowrap;
         font-weight:600;text-transform:uppercase;letter-spacing:0.5px}
    .sev.red{color:#fff;background:linear-gradient(135deg, #ff4757, #ff3742);border-color:rgba(255,60,60,.4);
             box-shadow:0 2px 8px rgba(255,60,60,.3)}
    .sev.blue{color:#fff;background:linear-gradient(135deg, #3742fa, #2f3542);border-color:rgba(60,150,255,.4);
              box-shadow:0 2px 8px rgba(60,150,255,.3)}
    .count-badge{
      position:absolute;background:rgba(255,165,0,.1);color:var(--orange);
      border:1px solid rgba(255,165,0,.35);padding:4px 8px;border-radius:8px;font-weight:700;font-size:12px;
      pointer-events:none;transform:translate(-50%,-130%);
    }
    .stats{
      background:#0b152c;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:12px;
    }
    
    /* Mobile tag adjustments */
    @media (max-width: 767px) {
      .tag{font-size:8px;padding:2px 4px;}
    }
  </style>
</head>
<body>
<div id="container">
  <div id="wf">
    <div class="hdr">
      R12 AUTOMATED PENTESTING TOOL IN ACTION
      <span class="tag" style="color:var(--purple)">AI + RAG</span>
      <span class="tag" style="color:var(--blue)">Tools</span>
      <span class="tag" style="color:var(--yellow)">Strategy</span>
      <span style="margin-left:auto;color:var(--green)">Live</span>
    </div>
    <div class="controls" style="display: none;">
      <input id="urlIn" placeholder="https://target.example.com" value="https://demo.site"/>
      <button id="startBtn">Start</button>
      <button id="pauseBtn">Pause</button>
    </div>
    <div class="stage">Ready (mock visualizer)</div>
  </div>
  <div id="sidebar">
    <div class="log">
      <h4>Vulnerabilities Log</h4>
      <div id="logItems"></div>
    </div>
    <div class="stats">
      <h4>Session Stats</h4>
      <div class="stat-row"><span>Endpoints Found:</span><span id="epCount">0</span></div>
      <div class="stat-row"><span>Vulns Discovered:</span><span id="vulnCount">0</span></div>
      <div class="stat-row"><span>Tools Used:</span><span id="toolCount">0</span></div>
    </div>
  </div>
</div>
<script>
(function(){
  // Demo tuning from reference
  const FIND_PROB = 0.60;
  const ENDPOINTS_RANGE = [8, 18];
  const STEP_MS = 750;

  const wf = document.getElementById('wf');
  const stage = wf.querySelector('.stage');
  const urlIn = document.getElementById('urlIn');
  const logItems = document.getElementById('logItems');
  const epCount = document.getElementById('epCount');
  const vulnCount = document.getElementById('vulnCount');
  const toolCount = document.getElementById('toolCount');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');

  // Set default URL for auto-start
  const defaultUrl = "https://demo.site";

  const css = getComputedStyle(document.documentElement);
  const C = k => css.getPropertyValue(k).trim();
  const COLORS = {
    text: C('--text')||'#eaf2ff',
    line: C('--line')||'rgba(140,170,255,.35)',
    accent: C('--accent')||'#7dd3fc',
    green: C('--green')||'#34d399',
    yellow: C('--yellow')||'#facc15',
    orange: C('--orange')||'#fb923c',
    blue: C('--blue')||'#60a5fa',
    purple: C('--purple')||'#a78bfa',
    pink: C('--pink')||'#f472b6',
    red: C('--red')||'#ff5c5c',
    blueok: C('--blue-ok')||'#5bbcff'
  };

  const NS="http://www.w3.org/2000/svg";
  const svg = mk('svg',{viewBox:'0 0 900 700', width:'100%', height:'100%', preserveAspectRatio:'xMidYMid meet'});
  
  // Responsive SVG positioning
  function updateSVGPosition() {
    if (window.innerWidth <= 767) {
      // Mobile: adjust for smaller sidebar
      svg.style.cssText = 'position:absolute;top:40px;left:0;right:112px;bottom:35px;';
    } else {
      // Desktop: original positioning
      svg.style.cssText = 'position:absolute;top:60px;left:0;right:320px;bottom:0;';
    }
  }
  
  updateSVGPosition();
  window.addEventListener('resize', updateSVGPosition);
  
  wf.appendChild(svg);
  const defs = mk('defs'); svg.appendChild(defs);
  const glow = mk('filter',{id:'glow', x:'-30%', y:'-30%', width:'160%', height:'160%'}); defs.appendChild(glow);
  glow.appendChild(mk('feGaussianBlur',{stdDeviation:'2', result:'b'}));
  const merge = mk('feMerge'); merge.appendChild(mk('feMergeNode',{in:'b'})); merge.appendChild(mk('feMergeNode',{in:'SourceGraphic'})); glow.appendChild(merge);

  const marker = mk('marker',{id:'arr', markerWidth:10, markerHeight:8, refX:10, refY:4, orient:'auto', markerUnits:'userSpaceOnUse'});
  marker.appendChild(mk('path',{d:'M0 0 L10 4 L0 8 Z', fill:COLORS.line}));
  defs.appendChild(marker);

  const edgeLayer = mk('g'); svg.appendChild(edgeLayer);
  const packetLayer = mk('g'); svg.appendChild(packetLayer);
  const nodeLayer = mk('g'); svg.appendChild(nodeLayer);

  // Enhanced workflow with strategy reschedule
  const nodes = [
    nd('URL','Target URL','Input',COLORS.green,'input'),
    nd('DISC','Discover Endpoints','discover',COLORS.orange,'process'),
    nd('AI','AI Planner (RAG)','AI',COLORS.purple,'process'),
    nd('TOOL','Tool Runner','tool',COLORS.blue,'process'),
    nd('ANALYZE','Analyze & Decide','feedback',COLORS.yellow,'process'),
    nd('STRATEGY','Strategy Reschedule','strategy',COLORS.pink,'process'),
    nd('LOG','Vulnerabilities Log','output',COLORS.red,'output')
  ];
  const edges = [
    ['URL','DISC'],
    ['DISC','AI'],
    ['AI','TOOL'],
    ['TOOL','ANALYZE'],
    ['ANALYZE','LOG'],
    ['ANALYZE','STRATEGY'],
    ['STRATEGY','AI']
  ];

  // Responsive node positioning
  function getNodePositions() {
    if (window.innerWidth <= 767) {
      // Mobile: bigger boxes in more compact layout
      return {
        'URL': {x: 150, y: 90},
        'DISC': {x: 450, y: 90},
        'AI': {x: 750, y: 90},
        'TOOL': {x: 750, y: 250},
        'ANALYZE': {x: 450, y: 380},
        'STRATEGY': {x: 150, y: 380},
        'LOG': {x: 150, y: 250}
      };
    } else {
      // Desktop: original positioning
      return {
        'URL': {x: 150, y: 103},
        'DISC': {x: 450, y: 103},
        'AI': {x: 750, y: 103},
        'TOOL': {x: 750, y: 303},
        'ANALYZE': {x: 750, y: 503},
        'STRATEGY': {x: 150, y: 503},
        'LOG': {x: 150, y: 303}
      };
    }
  }

  function updateNodePositions() {
    const positions = getNodePositions();
    nodes.forEach(n => {
      n.x = positions[n.id].x;
      n.y = positions[n.id].y;
      if (n.g) {
        n.g.setAttribute('transform', `translate(${n.x},${n.y})`);
      }
    });
  }

  nodes.forEach((n,i)=>{
    const positions = getNodePositions();
    n.x = positions[n.id].x;
    n.y = positions[n.id].y;
    n.active = false;
    n.processing = false;
    const g = mk('g'); nodeLayer.appendChild(g); n.g=g;
    
    // Responsive node sizing - BIGGER and ELONGATED boxes for mobile
    const isMobile = window.innerWidth <= 767;
    const w = isMobile ? 280 : 280;  // Increased from 240 to 280
    const h = isMobile ? 120 : 120;  // Increased from 100 to 120
    const r = isMobile ? 20 : 20;    // Increased from 18 to 20
    
    // Main card background with consistent thick colored outline
    n.box = mk('rect',{x:-w/2,y:-h/2,rx:r,ry:r,width:w-10,height:h, fill:'#101a33', stroke:n.color, 'stroke-width':1, filter:'url(#glow)'});
    // Glow outline for when data enters
    n.glowOutline = mk('rect',{x:-w/2-3,y:-h/2-3,rx:r+3,ry:r+3,width:w-3,height:h+6, fill:'none', stroke:n.color, 'stroke-width':5, opacity:0});
    // Main label
    const labelSize = isMobile ? 18 : 18;  // Increased from 16 to 18
    const label = tspan(-w/2+15,0,n.label,labelSize,COLORS.text,700);
    // Chip badge
    const chipX = isMobile ? w/2-70 : w/2-70;  // Adjusted for bigger box
    const chipY = isMobile ? -h/2+22 : -h/2+25;
    const chip = pill(chipX, chipY, n.chip, isMobile);
    // Endpoints counter (only for DISC node)
    if (n.id === 'DISC') {
      const endpointY = isMobile ? 30 : 25;  // Increased from 25 to 30
      n.endpointsText = tspan(-w/2+15, endpointY, '0 endpoints', isMobile ? 15 : 14, COLORS.orange, 600);  // Increased from 13 to 15
      n.endpointsText.setAttribute('opacity', '0.8');
    }
    // Processing icon (rotating gear)
    n.processingIcon = mk('g');
    const gearScale = isMobile ? 0.8 : 0.8;  // Increased from 0.7 to 0.8
    const gear = mk('path', {
      d: 'M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11.03L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11.03C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.04 4.95,18.95L7.44,17.95C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.95L19.05,18.95C19.27,19.04 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z',
      fill: n.color,
      opacity: 0.4,
      transform: `scale(${gearScale})`,
      'transform-origin': '12 12'
    });
    n.processingIcon.appendChild(gear);
    const gearX = isMobile ? 100 : 90;  // Adjusted for bigger box
    const gearY = isMobile ? 30 : 30;
    n.processingIcon.setAttribute('transform', `translate(${gearX}, ${gearY})`);
    n.gear = gear;
    // Status indicator
    const dotX = isMobile ? w/2-25 : w/2-20;  // Adjusted for bigger box
    const dotY = isMobile ? -h/2+20 : -h/2+20;
    n.statusDot = mk('circle', {r: isMobile ? 6 : 6, cx: dotX, cy: dotY, fill: '#555', opacity: 0.6});  // Increased from 5 to 6
    // Append elements to group
    if (n.id === 'DISC') {
      g.append(n.glowOutline, n.box, label, chip, n.endpointsText, n.processingIcon, n.statusDot);
    } else {
      g.append(n.glowOutline, n.box, label, chip, n.processingIcon, n.statusDot);
    }
    // Set initial position
    g.setAttribute('transform',`translate(${n.x},${n.y})`);
    // Add subtle hover effects - all boxes start with same thickness
    g.style.cursor = 'pointer';
    g.style.transition = 'all 0.3s ease';
    g.addEventListener('mouseenter', () => {
      n.box.setAttribute('stroke-width', '4');
      n.box.setAttribute('transform', 'scale(1.02)');
      n.statusDot.setAttribute('fill', n.color);
      n.statusDot.setAttribute('opacity', '0.8');
    });
    g.addEventListener('mouseleave', () => {
      n.box.setAttribute('stroke-width', '3');
      n.box.setAttribute('transform', 'scale(1)');
      n.statusDot.setAttribute('fill', '#555');
      n.statusDot.setAttribute('opacity', '0.6');
    });
  });

  const edgeEls = edges.map(([a,b])=>{
    const e = mk('line',{x1:0,y1:0,x2:0,y2:0, stroke:COLORS.line, 'stroke-width':1.8, markerEnd:'url(#arr)'});
    edgeLayer.appendChild(e);
    return {a:by(a), b:by(b), el:e};
  });

  // Token with larger halo effect
  const tokenSize = window.innerWidth <= 767 ? 7 : 8;  // Increased from 6 to 7
  const haloSize = window.innerWidth <= 767 ? 18 : 20;  // Increased from 15 to 18
  const token = mk('circle',{r:tokenSize, fill:COLORS.accent}); token.style.filter='url(#glow)'; svg.appendChild(token);
  const halo  = mk('circle',{r:haloSize, fill:'none', stroke:COLORS.accent, 'stroke-width':3, opacity:.18}); halo.style.filter='url(#glow)'; svg.appendChild(halo);
  moveTokenTo(by('URL'));

  // Handle window resize
  window.addEventListener('resize', () => {
    updateNodePositions();
    updateSVGPosition();
    render();
  });

  // Remove physics simulation - nodes are now fixed
  function render(){
    edgeEls.forEach(({a,b,el})=>{
       el.setAttribute('x1',a.x); el.setAttribute('y1',a.y);
       el.setAttribute('x2',b.x); el.setAttribute('y2',b.y);
    });
  }

  // Animation functions with glow effects
  function activateNode(node) {
    node.active = true;
    node.glowOutline.setAttribute('opacity', '0.8');
    node.glowOutline.animate([
      {opacity: '0'},
      {opacity: '0.8'},
      {opacity: '0.4'}
    ], {duration: 800, easing: 'ease-out'});
    node.statusDot.setAttribute('fill', node.color);
    node.statusDot.setAttribute('opacity', '1');
    // Start processing animation
    startProcessing(node);
  }

  function deactivateNode(node) {
    node.active = false;
    node.glowOutline.setAttribute('opacity', '0');
    node.statusDot.setAttribute('fill', '#555');
    node.statusDot.setAttribute('opacity', '0.6');
    stopProcessing(node);
  }

  function startProcessing(node) {
    if (!node.processing) {
      node.processing = true;
      animateGear(node);
    }
  }

  function stopProcessing(node) {
    node.processing = false;
  }

  function animateGear(node) {
    if (node.processing) {
      node.gear.animate([
        {transform: `rotate(0deg) scale(${window.innerWidth <= 767 ? 0.7 : 0.8})`},
        {transform: `rotate(360deg) scale(${window.innerWidth <= 767 ? 0.7 : 0.8})`}
      ], {
        duration: 2000,
        iterations: 1,
        easing: 'linear'
      }).onfinish = () => {
        if (node.processing) animateGear(node);
      };
    }
  }

  function packets(from,to,count=6,dur=STEP_MS,color=COLORS.accent){
    // Activate destination node when packets arrive
    activateNode(to);
    const packetCount = window.innerWidth <= 767 ? Math.max(4, Math.floor(count * 0.7)) : count;  // Increased from 3 to 4
    for(let i=0;i<packetCount;i++){
      const p = mk('circle',{r:window.innerWidth <= 767 ? 2.5 : 3, fill:color, opacity:0.9});  // Increased from 2 to 2.5
      packetLayer.appendChild(p);
      
      // Create comet trail effect
      const trail = [];
      const trailLength = window.innerWidth <= 767 ? 4 : 5;  // Increased from 3 to 4
      for(let j = 0; j < trailLength; j++) {
        const trailDot = mk('circle', {
          r: (window.innerWidth <= 767 ? 1.8 : 2) - (j * 0.3),  // Increased from 1.5 to 1.8
          fill: color, 
          opacity: 0.6 - (j * 0.1)
        });
        packetLayer.appendChild(trailDot);
        trail.push(trailDot);
      }
      
      const start = performance.now()+ i*80;
      const positions = [];
      
      const tick = now=>{
        const t = Math.min(1,(now-start)/dur);
        const x = lerp(from.x,to.x,ease(t)), y = lerp(from.y,to.y,ease(t));
        
        // Update main packet position
        p.setAttribute('cx',x); p.setAttribute('cy',y);
        p.setAttribute('opacity', String(0.9*(1-t)));
        
        // Store current position for trail
        positions.push({x, y});
        if(positions.length > trailLength) positions.shift();
        
        // Update trail positions
        trail.forEach((trailDot, index) => {
          const trailPos = positions[positions.length - 1 - index];
          if(trailPos) {
            trailDot.setAttribute('cx', trailPos.x);
            trailDot.setAttribute('cy', trailPos.y);
            trailDot.setAttribute('opacity', String((0.6 - (index * 0.1)) * (1-t)));
          }
        });
        
        if(t<1) {
          requestAnimationFrame(tick);
        } else {
          packetLayer.removeChild(p);
          trail.forEach(trailDot => packetLayer.removeChild(trailDot));
        }
      };
      requestAnimationFrame(tick);
    }
  }

  function move(from,to,dur=STEP_MS,cb){
    // Deactivate source, activate destination
    deactivateNode(from);
    const start = performance.now();
    const go = now=>{
      const t = Math.min(1,(now-start)/dur);
      const x = lerp(from.x,to.x,ease(t)), y = lerp(from.y,to.y,ease(t));
      token.setAttribute('cx',x); token.setAttribute('cy',y);
      halo.setAttribute('cx',x);  halo.setAttribute('cy',y);
      if(t<1) requestAnimationFrame(go);
      else {
         const haloSize = window.innerWidth <= 767 ? 18 : 18;  // Increased from 15 to 18
         const haloSizeEnd = window.innerWidth <= 767 ? 23 : 25;  // Increased from 20 to 23
         halo.animate([{r:haloSize,opacity:.25},{r:haloSizeEnd,opacity:.12},{r:haloSize,opacity:.22}],{duration:600,iterations:1,easing:'ease-in-out'});
         cb && cb();
       }
    };
    requestAnimationFrame(go);
  }
  function moveTokenTo(n){ token.setAttribute('cx',n.x); token.setAttribute('cy',n.y); halo.setAttribute('cx',n.x); halo.setAttribute('cy',n.y); }

  // Demo state
  const tools = ['SQLMap','Nuclei','ffuf','Custom'];
  const vulns = ['SQL Injection','XSS','SSRF','Open Redirect','Dir Traversal','RCE','CSRF','IDOR','Clickjacking'];
  const endpointsKinds = ['form','api','upload','search','redirect','admin'];

  let running=false;
  let paused=false;
  let epTotal=0, epLeft=0, vulnTotal=0, toolsUsed=new Set();

  function reset(){
    logItems.innerHTML='';
    epTotal=epLeft=vulnTotal=0;
    toolsUsed.clear();
    updateStats();
    setTool('Tool Runner');
    stage.textContent='Ready (mock)';
    moveTokenTo(by('URL'));
    hideBadge();
    // Deactivate all nodes
    nodes.forEach(deactivateNode);
  }

  function start(){
    if(running) return;
    running=true;
    paused=false;
    if(pauseBtn) pauseBtn.textContent = 'Pause';
    discover();
  }

  function discover() {
    const URL = by('URL'), DISC = by('DISC');
    stage.textContent='Deep scanning for endpoints and attack vectors...';
    epTotal = randInt(ENDPOINTS_RANGE[0], ENDPOINTS_RANGE[1]);
    epLeft = epTotal;
    updateStats();
    showBadge(epLeft);
    packets(URL, DISC, 10, STEP_MS, COLORS.accent);
    move(URL, DISC, STEP_MS, aiPick);
  }

  function aiPick(){
    if (epLeft<=0){
      stage.textContent='Cycle complete. Rescanning…';
      setTimeout(discover, 600);
      return;
    }
    const DISC = by('DISC'), AI = by('AI');
    const pickedEndpoint = randOf(endpointsKinds);
    const pickedTool = randOf(tools);
    setTool(pickedTool);
    toolsUsed.add(pickedTool);
    updateStats();
    stage.textContent=`AI targeting ${pickedEndpoint} endpoint with ${pickedTool}...`;
    packets(DISC, AI, 6, STEP_MS, COLORS.orange);
    move(DISC, AI, STEP_MS, ()=> toolRun(pickedTool));
  }

  function toolRun(tool){
    const AI = by('AI'), TOOL = by('TOOL'), ANALYZE = by('ANALYZE');
    packets(AI, TOOL, 6, STEP_MS, COLORS.purple);
    move(AI, TOOL, STEP_MS, ()=>{
      const found = Math.random() < FIND_PROB;
      const color = found ? COLORS.red : COLORS.blueok;
      pulseBorder(TOOL.box, found ? 'red' : 'blue');
      packets(TOOL, ANALYZE, 10, STEP_MS, color);
      move(TOOL, ANALYZE, STEP_MS, ()=>{
        epLeft--; showBadge(epLeft);
        if(found){
          const vuln = randOf(vulns);
          logVuln(defaultUrl, vuln, tool);
          stage.textContent=`ALERT: ${vuln} discovered! Logging critical finding...`;
          const L = by('LOG');
          packets(ANALYZE, L, 6, STEP_MS*0.8, COLORS.red);
          move(ANALYZE, L, STEP_MS*0.8, ()=> setTimeout(aiPick, 300));
        }else{
          stage.textContent=`${tool} scan clean. Escalating to strategy module...`;
          setTimeout(strategy, 200);
        }
      });
    });
  }

  function toolRunDirect(tool){
    const AI = by('AI'), TOOL = by('TOOL'), ANALYZE = by('ANALYZE');
    packets(AI, TOOL, 6, STEP_MS, COLORS.purple);
    move(AI, TOOL, STEP_MS, ()=>{
      const found = Math.random() < FIND_PROB;
      const color = found ? COLORS.red : COLORS.blueok;
      pulseBorder(TOOL.box, found ? 'red' : 'blue');
      packets(TOOL, ANALYZE, 10, STEP_MS, color);
      move(TOOL, ANALYZE, STEP_MS, ()=>{
        epLeft--; showBadge(epLeft);
        if(found){
          const vuln = randOf(vulns);
          logVuln(defaultUrl, vuln, tool);
          stage.textContent=`VULNERABILITY: ${vuln} found via ${tool}! Securing data...`;
          const L = by('LOG');
          packets(ANALYZE, L, 6, STEP_MS*0.8, COLORS.red);
          move(ANALYZE, L, STEP_MS*0.8, ()=> setTimeout(aiPick, 300));
        }else{
          stage.textContent=`${tool} analysis complete. Engaging strategy optimization...`;
          setTimeout(strategy, 200);
        }
      });
    });
  }

  function strategy(){
    const ANALYZE = by('ANALYZE'), STRATEGY = by('STRATEGY');
    stage.textContent='Strategy reschedule…';
    packets(ANALYZE, STRATEGY, 8, STEP_MS, COLORS.pink);
    move(ANALYZE, STRATEGY, STEP_MS, ()=>{
      const AI = by('AI');
      stage.textContent='Strategy feeding back to AI Planner…';
      packets(STRATEGY, AI, 6, STEP_MS, COLORS.pink);
      move(STRATEGY, AI, STEP_MS, ()=>{
        const pickedTool = randOf(tools);
        setTool(pickedTool);
        toolsUsed.add(pickedTool);
        updateStats();
        stage.textContent=`AI strategically selected ${pickedTool} for enhanced scanning...`;
        setTimeout(()=> toolRunDirect(pickedTool), 200);
      });
    });
  }

  // UI helpers
  function setTool(name){
    const n = by('TOOL');
    n.g.querySelector('text').textContent = name;
  }
  function pulseBorder(box, kind){
    const col = kind==='red' ? 'rgba(255,80,80,1)' : 'rgba(90,170,255,.9)';
    box.setAttribute('stroke', col); box.setAttribute('stroke-width','2.2');
    setTimeout(()=>{ box.setAttribute('stroke', by('TOOL').color); box.setAttribute('stroke-width','3'); }, 480);
  }
  function logVuln(url, vuln, tool){
    const row = document.createElement('div');
    row.className='item';
    
    // Add vulnerability indicators for professional appearance
    const vulnIcons = {
      'SQL Injection': '[SQL]',
      'XSS': '[XSS]',
      'SSRF': '[SSRF]',
      'Open Redirect': '[RDIR]',
      'Dir Traversal': '[PATH]',
      'RCE': '[RCE]',
      'CSRF': '[CSRF]',
      'IDOR': '[IDOR]',
      'Clickjacking': '[CLICK]'
    };
    
    const icon = vulnIcons[vuln] || '[VULN]';
    const severity = Math.random() > 0.6 ? 'CRITICAL' : 'HIGH';
    const severityClass = severity === 'CRITICAL' ? 'red' : 'blue';
    
    row.innerHTML = `<div>
                       <span style="margin-right:8px;font-size:14px">${icon}</span>
                       <b style="color:#ff6b6b">${esc(vuln)}</b> 
                       <span style="opacity:.7;font-size:11px">detected via</span> 
                       <span style="color:#4ecdc4;font-weight:600">${esc(tool)}</span>
                       <br><span style="opacity:.6;font-size:10px;margin-left:22px">${esc(url)}</span>
                     </div>
                     <span class="sev ${severityClass}">${severity}</span>`;
    
    logItems.prepend(row);
    
    // Add entry animation
    row.style.transform = 'translateX(-100%)';
    row.style.opacity = '0';
    setTimeout(() => {
      row.style.transition = 'all 0.5s ease';
      row.style.transform = 'translateX(0)';
      row.style.opacity = '1';
    }, 50);
    
    vulnTotal++;
    updateStats();
    while(logItems.children.length>15) logItems.removeChild(logItems.lastChild);
  }
  function showBadge(count){
    const d = by('DISC'); 
    if(!d.endpointsText) return;
    d.endpointsText.textContent = `${count} endpoints`;
    // Animate the text with a subtle pulse effect
    d.endpointsText.animate([
      {opacity: '0.8', transform: 'scale(1)'},
      {opacity: '1', transform: 'scale(1.05)'},
      {opacity: '0.8', transform: 'scale(1)'}
    ], {duration: 360, easing: 'ease-in-out'});
  }
  function hideBadge(){ 
    const d = by('DISC'); 
    if(d.endpointsText) d.endpointsText.textContent = '0 endpoints'; 
  }
  function updateStats(){
    epCount.textContent = epTotal;
    vulnCount.textContent = vulnTotal;
    toolCount.textContent = toolsUsed.size;
  }

  // Frame loop
  function frame(){
    if(!paused){
      render();
    }
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Controls - Auto-start the workflow
  setTimeout(() => {
    try {
      reset();
      start();
      console.log('Pentest demo started successfully');
    } catch (error) {
      console.error('Error starting pentest demo:', error);
      stage.textContent = 'Demo initialization error - refreshing...';
      setTimeout(() => {
        try {
          reset();
          start();
        } catch (retryError) {
          console.error('Retry failed:', retryError);
          stage.textContent = 'Demo offline - please refresh page';
        }
      }, 2000);
    }
  }, 1000); // Start after 1 second delay

  // Utils
  function by(id){ return nodes.find(n=>n.id===id); }
  function nd(id,label,chip,color,kind){ return {id,label,chip,color,kind}; }
  function mk(tag,attrs){ const e=document.createElementNS(NS,tag); for(const k in attrs) e.setAttribute(k,attrs[k]); return e; }
  function tspan(x,y,txt,size,fill,weight){ const t=mk('text',{x,y,'dominant-baseline':'middle','font-size':size, fill, 'font-weight':weight||500}); t.textContent=txt; return t; }
  function pill(x,y,text,isMobile){ 
    const g=mk('g'); 
    const w=isMobile ? 70 : 80;  // Increased from 60 to 70
    const h=isMobile ? 22 : 25;  // Increased from 20 to 22
    const r=isMobile ? 11 : 12;  // Increased from 10 to 11
    g.appendChild(mk('rect',{x:x-w/2,y:y-h/2,rx:r,ry:r,width:w,height:h,fill:'rgba(255,255,255,.06)',stroke:'rgba(255,255,255,.12)','stroke-width':1}));
    const t=tspan(x,y,text,isMobile ? 11 : 12,COLORS.text,500); t.setAttribute('text-anchor','middle'); g.appendChild(t); return g;  // Increased from 10 to 11
  }
  function lerp(a,b,t){ return a+(b-a)*t; }
  function ease(t){ return t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }
  function esc(s){ return String(s).replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m])); }
  function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
  function randOf(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
})();
</script>
</body>
</html>
